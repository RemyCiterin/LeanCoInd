import CoInd.M
import CoInd.Paco
import CoInd.Tactic
import CoInd.Container
import CoInd.Utils
import Mathlib.Tactic.Eqns
import CoInd.Std.DelabRule
import Mathlib.Order.OmegaCompletePartialOrder
import Mathlib.Topology.OmegaCompletePartialOrder
import CoInd.OmegaCompletePartialOrder
import CoInd.Notation

import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Monotonicity.Basic

import Lean
import Lean.Data.RBMap
import Lean.Data.RBTree
import Qq
import CoInd.Kahn


open OmegaCompletePartialOrder

instance {I: Type u} {Œ±: I ‚Üí Type v} [‚àÄ i, Preorder (Œ± i)] [‚àÄ i, OrderBot (Œ± i)]
  : OrderBot (‚àÄ i, Œ± i) where
  bot_le := by
    intro f x
    apply bot_le

instance {Œ±: Type u} : OrderBot (Kahn Œ±) where
  bot_le := Kahn.bot_le


namespace OmegaCompletePartialOrder.Admissible

instance {Œ±: Type u} [OmegaCompletePartialOrder Œ±] [OrderBot Œ±] : Top (Admissible Œ±) where
  top :=
    ‚ü®
      Œª _ => True,
      by intro _ _; trivial,
      by trivial
    ‚ü©

-- using a function from (x: Œ±) to a set of admissible property over (Œ≤ x), construct
-- an admissible property over ((x: Œ±) ‚Üí Œ≤ x)
def foreach {Œ±: Type u} {Œ≤: Œ± ‚Üí Type v} [‚àÄ x, OmegaCompletePartialOrder (Œ≤ x)] [‚àÄ x, OrderBot (Œ≤ x)]
  (P : ‚àÄ x, Admissible (Œ≤ x)) : Admissible (‚àÄ x, Œ≤ x) where
  toSet f := ‚àÄ x, f x ‚àà P x
  contain_bot := by
    intro x
    apply contain_bot
  admissible' := by
    intro chain h‚ÇÅ x
    apply admissible
    intro n
    apply h‚ÇÅ

@[refinment_type]
def foreach.apply {Œ±: Type u} {Œ≤: Œ± ‚Üí Type v} [‚àÄ x, OmegaCompletePartialOrder (Œ≤ x)] [‚àÄ x, OrderBot (Œ≤ x)]
  (P : ‚àÄ x, Admissible (Œ≤ x)) (f: ‚àÄ x, Œ≤ x) (hyp: ‚àÄ x, f x ‚àà P x) : f ‚àà foreach P := hyp

def prod {Œ±: Type u} {Œ≤: Type v}
  [OmegaCompletePartialOrder Œ±] [OmegaCompletePartialOrder Œ≤] [OrderBot Œ±] [OrderBot Œ≤]
  (P: Admissible Œ±) (Q: Admissible Œ≤) : Admissible (Œ± √ó Œ≤) where
  toSet pair := pair.fst ‚àà P ‚àß pair.snd ‚àà Q
  admissible' := by
    intro chain h‚ÇÅ
    constructor
    ¬∑ apply admissible
      intro n
      apply (h‚ÇÅ n).left
    ¬∑ apply admissible
      intro n
      apply (h‚ÇÅ n).right
  contain_bot := by
    constructor
    ¬∑ apply contain_bot
    ¬∑ apply contain_bot

@[refinment_type]
def prod.apply {Œ±: Type u} {Œ≤: Type v}
  [OmegaCompletePartialOrder Œ±] [OmegaCompletePartialOrder Œ≤] [OrderBot Œ±] [OrderBot Œ≤]
  (P: Admissible Œ±) (Q: Admissible Œ≤) (a: Œ±) (b: Œ≤) (h‚ÇÅ: a ‚àà P) (h‚ÇÇ: b ‚àà Q) : (a, b) ‚àà prod P Q :=
  ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©

#check ContinuousHom.Prod.curry



end OmegaCompletePartialOrder.Admissible


namespace Lustre

structure Env where
  var : Type u
  type : var ‚Üí Type u

def Env.State (E: Env.{u}) := (v: E.var) ‚Üí E.type v

@[simp]
def Env.add.var (A B: Env.{u}) : Type u := A.var ‚äï B.var

@[simp]
def Env.add.type (A B: Env.{u}) : Env.add.var A B ‚Üí Type u
| .inl a => A.type a
| .inr b => B.type b

abbrev Str (A: Env.{u}) := ‚àÄ a: A.var, Kahn (A.type a)

inductive Square.SetF {Œ±: Type u} (P: Set Œ±)
  (aux: Set (Kahn Œ±)) (s: Kahn Œ±) : Prop where
| bot : ‚ä• = s ‚Üí SetF P aux s
| cons x xs : x ::: xs = s ‚Üí P x ‚Üí aux xs ‚Üí SetF P aux s

@[simps! coe]
def Square.SetF_mono {Œ±: Type u} (P: Set Œ±) : (Kahn Œ± ‚Üí Prop) ‚Üío (Kahn Œ± ‚Üí Prop) where
  toFun aux x := Square.SetF P aux x
  monotone' s‚ÇÅ s‚ÇÇ h‚ÇÅ x h‚ÇÇ := by
    cases x using Kahn.cases with
    | bot =>
      apply SetF.bot
      rfl
    | cons x xs =>
      apply SetF.cons x xs
      ¬∑ rfl
      ¬∑ cases h‚ÇÇ with
        | bot h‚ÇÉ =>
          simp [Bot.bot, Kahn.cons] at h‚ÇÉ
        | cons y ys h‚ÇÉ h‚ÇÑ h‚ÇÖ =>
          rw [Kahn.cons.injEq] at h‚ÇÉ
          induction h‚ÇÉ.left
          induction h‚ÇÉ.right
          assumption
      ¬∑ cases h‚ÇÇ with
        | bot h‚ÇÉ =>
          simp [Bot.bot, Kahn.cons] at h‚ÇÉ
        | cons y ys h‚ÇÉ h‚ÇÑ h‚ÇÖ =>
          rw [Kahn.cons.injEq] at h‚ÇÉ
          induction h‚ÇÉ.left
          induction h‚ÇÉ.right
          apply h‚ÇÅ
          assumption


noncomputable def Square {Œ±: Type u} (P: Set Œ±) : Admissible (Kahn Œ±) where
  toSet s := pgfp (Square.SetF_mono P) ‚ä• s

  admissible' := by
    intro chain h‚ÇÅ
    coinduction [h‚ÇÅ] generalizing [chain] using pgfp.theorem (Square.SetF_mono P)
    clear h‚ÇÅ chain
    intro _ ‚ü®chain, eq‚ÇÅ, h‚ÇÅ‚ü©
    induction eq‚ÇÅ
    rw [Kahn.œâSup.unfold]
    cases Kahn.findCons chain with
    | bot h‚ÇÇ =>
      apply Square.SetF.bot
      rfl
    | cons n x xs h‚ÇÇ =>
      apply Square.SetF.cons x (œâSup xs)
      ¬∑ rfl
      ¬∑ specialize h‚ÇÅ (n+0)
        rw [‚Üêh‚ÇÇ 0, ‚Üêpgfp.unfold] at h‚ÇÅ
        cases h‚ÇÅ with
        | bot h‚ÇÉ =>
          simp [Bot.bot, Kahn.cons] at h‚ÇÉ
        | cons y ys h‚ÇÉ h‚ÇÑ h‚ÇÖ =>
          rw [Kahn.cons.injEq] at h‚ÇÉ
          induction h‚ÇÉ.left
          assumption
      ¬∑ apply Or.inl
        exists xs
        constructor
        ¬∑ rfl
        ¬∑ intro m
          specialize h‚ÇÅ (n+m)
          rw [‚Üêh‚ÇÇ m, ‚Üêpgfp.unfold] at h‚ÇÅ
          cases h‚ÇÅ with
          | bot h‚ÇÉ =>
            simp [Bot.bot, Kahn.cons] at h‚ÇÉ
          | cons y ys h‚ÇÉ h‚ÇÑ h‚ÇÖ =>
            rw [Kahn.cons.injEq] at h‚ÇÉ
            induction h‚ÇÉ.left
            induction Eq.symm h‚ÇÉ.right
            cases h‚ÇÖ with
            | inl h =>
              cases h
            | inr h =>
              exact h

  contain_bot := by
    rw [‚Üêpgfp.unfold]
    apply Square.SetF.bot
    rfl

#check pgfp.unfold

@[refinment_type]
def Square.unfold_cons {Œ±: Type u} (P: Set Œ±) (x: Œ±) (xs: Kahn Œ±) :
  x ‚àà P ‚Üí xs ‚àà Square P ‚Üí x ::: xs ‚àà Square P := by
  intro h‚ÇÅ h‚ÇÇ
  simp only [Square, Membership.mem]
  rw [‚Üêpgfp.unfold]
  apply Square.SetF.cons x xs rfl h‚ÇÅ (Or.inr h‚ÇÇ)

@[simp]
def Square.rewrite_cons {Œ±: Type u} (P: Set Œ±) (x: Œ±) (xs: Kahn Œ±) :
  (x ::: xs ‚àà Square P) = (x ‚àà P ‚àß xs ‚àà Square P) := by
  apply propext
  constructor
  ¬∑ intro h
    simp only [Square, Membership.mem] at h
    rw [‚Üêpgfp.unfold] at h
    cases h with
    | bot eq =>
      simp [Bot.bot, Kahn.cons] at eq
    | cons y ys eq h‚ÇÅ h‚ÇÇ =>
      rw [Kahn.cons.injEq] at eq
      induction eq.left
      induction eq.right
      constructor
      ¬∑ exact h‚ÇÅ
      ¬∑ cases h‚ÇÇ with
        | inl h =>
          cases h
        | inr h =>
          exact h
  ¬∑ intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    refinment_type


@[refinment_type]
def Square.unfold_bot {Œ±: Type u} (P: Set Œ±) :
  ‚ä•  ‚àà Square P := by
  simp only [Square, Membership.mem]
  rw [‚Üêpgfp.unfold]
  apply Square.SetF.bot rfl

def Square.coind {Œ±: Type u} (P: Set Œ±) (hyp: Kahn Œ± ‚Üí Prop) :
  (‚àÄ x, hyp x ‚Üí Square.SetF P (Œª x => hyp x ‚à® x ‚àà Square P) x)
  ‚Üí ‚àÄ x, hyp x ‚Üí x ‚àà Square P := by
  intro h‚ÇÅ x h‚ÇÇ
  simp only [Membership.mem, Square]
  apply pgfp.theorem _ hyp
  clear h‚ÇÇ x
  intro x h‚ÇÇ
  specialize h‚ÇÅ x h‚ÇÇ
  have : (fun x => hyp x ‚à® x ‚àà Square P) ‚â§ hyp ‚äî (pgfp (SetF_mono P)) hyp := by
    intro x h‚ÇÅ
    cases h‚ÇÅ with
    | inl h => apply Or.inl h
    | inr h =>
      apply Or.inr
      apply (pgfp (SetF_mono P)).monotone bot_le
      exact h
  apply (SetF_mono P).monotone this
  apply h‚ÇÅ
  apply h‚ÇÇ


open Lean Elab Meta in
inductive Ast : Type where
| ident : Ident ‚Üí Ast
| app : Term ‚Üí List Ast ‚Üí Ast
| showFrom : Ast ‚Üí Term ‚Üí Ast
| term : Term ‚Üí Ast

namespace Ast

open Lean Elab Meta

structure Node where
  inputs : List (Ident √ó Term)       -- input variables
  outputs : List (Ast √ó Term)        -- output variables and their definitions
  locals : List (Ident √ó Term √ó Ast) -- local variables and their recursive definitions

inductive IR where
| showFrom : IR ‚Üí Term ‚Üí IR
| term : Term ‚Üí IR -- term antiquotation
| app : Term ‚Üí List IR ‚Üí IR -- sub-node
| loc : Nat ‚Üí IR -- n-th local variable
| input : Nat ‚Üí IR -- n-th input variable

open TSyntax.Compat in
def parseExplicitBindersAux (idents : Array Syntax) (type? : Option Syntax) (acc: List (Ident √ó Option Term))
  : MacroM (List (Ident √ó Option Term)) :=
  let rec loop (i : Nat) (acc : List (Ident √ó Option Term)) := do
    match i with
    | 0   => pure acc
    | i+1 =>
      let ident := (idents[i]!)[0]
      let acc := match ident.isIdent, type? with
        | true,  none      => (ident, none) :: acc
        | true,  some type => (ident, some type) :: acc
        | false, none      => (mkIdent `_, none) :: acc
        | false, some type => (mkIdent `_, some type) :: acc
      loop i acc
  loop idents.size acc

def parseBrackedBindersAux (binders : Array Syntax) (acc: List (Ident √ó Option Term))
  : MacroM (List (Ident √ó Option Term)) :=
  let rec loop (i : Nat) (acc : List (Ident √ó Option Term)) := do
    match i with
    | 0   => pure acc
    | i+1 =>
      let idents := (binders[i]!)[1].getArgs
      let type   := (binders[i]!)[3]
      loop i (‚Üê parseExplicitBindersAux idents (some type) acc)
  loop binders.size acc

partial def parseBinders (explicitBinders: Syntax) : MacroM (List (Ident √ó Option Term)) := do
  let explicitBinders := explicitBinders[0]
  if explicitBinders.getKind == ``Lean.unbracketedExplicitBinders then
    let idents   := explicitBinders[0].getArgs
    let type? := if explicitBinders[1].isNone then none else some explicitBinders[1][1]
    parseExplicitBindersAux idents type? []
  else if explicitBinders.getArgs.all (¬∑.getKind == ``Lean.bracketedExplicitBinders) then
    parseBrackedBindersAux explicitBinders.getArgs []
  else
    Macro.throwError "unexpected explicit binder"

declare_syntax_cat lustre_term
declare_syntax_cat lustre_decl
declare_syntax_cat lustre_eq

syntax ident : lustre_term -- used to determine arguments and antiquotation
syntax "(" lustre_term ")" : lustre_term
syntax "(" lustre_term " : " term ")" : lustre_term
syntax "{" term "}" : lustre_term -- antiquotation
syntax "{" term "}" "(" lustre_term,* ")" : lustre_term -- function application

syntax ident ":" term ":=" lustre_term : lustre_eq
syntax ident ":=" lustre_term : lustre_eq

syntax "defnode" ident explicitBinders ":=" lustre_term "where" lustre_eq+ : command

instance : Inhabited Ast := ‚ü®.ident (mkIdent `_)‚ü©
instance : Inhabited IR := ‚ü®.term (mkIdent `_)‚ü©

partial def parse_term : TSyntax `lustre_term ‚Üí MacroM Ast
| `(lustre_term| $i:ident) => pure (.ident i)
| `(lustre_term| { $t:term }) => pure (.term t)
| `(lustre_term| ( $t:lustre_term )) => parse_term t
| `(lustre_term| ( $t:lustre_term : $typ:term )) => do
  return .showFrom (‚Üêparse_term t) typ
| `(lustre_term| { $t‚ÇÅ:term } ($t‚ÇÇ:lustre_term,*)) => do
  have t‚ÇÇ: Array (TSyntax `lustre_term) := t‚ÇÇ
  let t‚ÇÇ: List Ast ‚Üê List.mapM parse_term t‚ÇÇ.toList
  return .app t‚ÇÅ t‚ÇÇ
| _ => Macro.throwError "unsupported syntax"

-- replace idents by De Bruijn index
partial def compile (inputs: List Ident) (locals: List Ident) : Ast ‚Üí IR
| .ident name =>
  if let idx :: _ := List.findIdxs (Œª n => n == name) locals
  then .loc idx
  else
    if let idx :: _ := List.findIdxs (Œª n => n == name) inputs
    then .input idx
    else .term name
| .app function args =>
  .app function (compile inputs locals <$> args)
| .showFrom t type =>
  .showFrom (compile inputs locals t) type
| .term t => .term t

def getPath (numArgs: Nat) : Nat ‚Üí MacroM Term
| n+1 => do
  `(term| OmegaCompletePartialOrder.ContinuousHom.comp $(‚ÜêgetPath (numArgs-1) n) OmegaCompletePartialOrder.ContinuousHom.Prod.snd)
| 0 =>
  if numArgs = 1
  then  `(term| OmegaCompletePartialOrder.ContinuousHom.id)
  else `(term| OmegaCompletePartialOrder.ContinuousHom.Prod.fst)

-- return a function of type Inputs √ó Locals ‚ÜíùíÑ argType
def getInput (arg: Nat) (numInputs: Nat) : MacroM Term := do
  `(term| OmegaCompletePartialOrder.ContinuousHom.comp $(‚ÜêgetPath numInputs arg) OmegaCompletePartialOrder.ContinuousHom.Prod.fst)

-- return a function of type Inputs √ó Locals ‚ÜíùíÑ argType
def getLoc (arg: Nat) (numLocals: Nat) : MacroM Term := do
  `(term| OmegaCompletePartialOrder.ContinuousHom.comp $(‚ÜêgetPath numLocals arg) OmegaCompletePartialOrder.ContinuousHom.Prod.snd)

#print IR

#check ContinuousHom.Prod.curry
#check ContinuousHom.Prod.prod
#check Nat.foldM
#check List.foldlM


partial def IR.toTerm (numInputs numLocals: Nat) : IR ‚Üí MacroM Term
| .showFrom ir t => do `(term| (show _ √ó _ ‚ÜíùíÑ Kahn $t from $(‚Üêir.toTerm numInputs numLocals)))
| .input n => getInput n numInputs
| .loc n => getLoc n numLocals
| .term t => `(term| OmegaCompletePartialOrder.ContinuousHom.const $t)
| .app function [] => do
  `(term| OmegaCompletePartialOrder.ContinuousHom.const $function)
| .app function args => do
  -- A list of terms of type I √ó L ‚ÜíùíÑ T·µ¢
  let args ‚Üê List.mapM (toTerm numInputs numLocals) args
  let function ‚Üê
    Nat.foldM
      (Œª _ t => `(term| OmegaCompletePartialOrder.ContinuousHom.Prod.curry.symm $t))
      function (args.length - 1)
  -- function is of type T‚ÇÄ √ó ... √ó T‚Çô ‚ÜíùíÑ T
  -- return a term of type I √ó L ‚ÜíùíÑ T

  -- we want a term of type I √ó L ‚ÜíùíÑ T‚ÇÄ √ó ... √ó T‚Çô : construct the arguments from the context
  let args_fun ‚Üê genArgs (List.reverse args)
  `(term| OmegaCompletePartialOrder.ContinuousHom.comp $function $args_fun)
where
  genArgs : List Term ‚Üí MacroM Term
  | [] => Macro.throwError "empty function application"
  | [t] => pure t
  | x :: xs => do
    `(term| OmegaCompletePartialOrder.ContinuousHom.Prod.prod $(‚ÜêgenArgs xs) $x)

syntax "ŒªÀ°·µòÀ¢·µó ≥·µâ" explicitBinders "=>" explicitBinders "=>" lustre_term : term

def prodOfList : List Term ‚Üí MacroM Term
| [] => Macro.throwError ""
| [x] => pure x
| x :: xs => do
  `($x √ó $(‚ÜêprodOfList xs))

macro_rules
| `(term| ŒªÀ°·µòÀ¢·µó ≥·µâ $b‚ÇÅ:explicitBinders => $b‚ÇÇ:explicitBinders => $body:lustre_term) => do
  have body : TSyntax `lustre_term := .mk <| ‚Üê expandMacros body
  let l‚ÇÅ ‚Üê parseBinders b‚ÇÅ
  let l‚ÇÇ ‚Üê parseBinders b‚ÇÇ
  let ast ‚Üê parse_term body
  let ir := ast.compile (Prod.fst <$> l‚ÇÅ) (Prod.fst <$> l‚ÇÇ)
  let empty : Term ‚Üê `(term| _)
  let l‚ÇÅ_type := (Œª (_, t) =>
    match t with
    | .some v => v
    | .none => empty
  ) <$> l‚ÇÅ
  let l‚ÇÇ_type := (Œª (_, t) =>
    match t with
    | .some v => v
    | .none => empty
  ) <$> l‚ÇÇ
  `(term| show $(‚ÜêprodOfList l‚ÇÅ_type) √ó $(‚ÜêprodOfList l‚ÇÇ_type) ‚ÜíùíÑ _ from $(‚Üêir.toTerm l‚ÇÅ.length l‚ÇÇ.length))


def parseEq : TSyntax `lustre_eq ‚Üí MacroM (Ident √ó Term √ó TSyntax `lustre_term)
| `(lustre_eq| $i:ident : $t:term := $l:lustre_term) =>
  pure (i, t, l)
| `(lustre_eq| $i:ident := $l:lustre_term) => do
  return (i, ‚Üê`(term| _), l)
| _ => Macro.throwUnsupported

macro_rules
| `(command| defnode $name_ident:ident $b‚ÇÅ:explicitBinders := $out:lustre_term where $eqs:lustre_eq*) => do
  let empty : Term ‚Üê `(term| _)

  have inputs := (Œª (i, t) => (i, Option.getD t empty)) <$> (‚Üê parseBinders b‚ÇÅ)
  let locals ‚Üê List.mapM parseEq eqs.toList

  have inputs_name := (Œª (name, _) => name) <$> inputs
  have inputs_type := (Œª (_, type) => type) <$> inputs

  have locals_name := (Œª (name, _, _) => name) <$> locals
  have locals_type := (Œª (_, type, _) => type) <$> locals
  have locals_term := (Œª (_, _, expr) => expr) <$> locals

  have output_ir := (‚Üêparse_term out).compile inputs_name locals_name
  let output_term ‚Üê
    `(show
        $(‚ÜêprodOfList inputs_type) √ó $(‚ÜêprodOfList locals_type) ‚ÜíùíÑ _
      from
        $(‚Üêoutput_ir.toTerm inputs_type.length locals_type.length)
    )


  let locals_ir ‚Üê
    List.mapM (Œª eq => do
      return (‚Üêparse_term eq).compile inputs_name locals_name
    ) locals_term

  let locals_term ‚Üê
    List.mapM (Œª ir => do
      `(show
          $(‚ÜêprodOfList inputs_type) √ó $(‚ÜêprodOfList locals_type) ‚ÜíùíÑ _
        from
          $(‚Üêir.toTerm inputs_type.length locals_type.length)
      )
    ) locals_ir

  `(command|
    def $name_ident := $output_term
  )

defnode foo (i: Kahn ‚Ñï) := l‚ÇÅ
  where
    l‚ÇÅ : Kahn ‚Ñï := i

#print foo



variable (I‚ÇÅ I‚ÇÇ I‚ÇÉ L‚ÇÅ L‚ÇÇ L‚ÇÉ: Type)
variable (foo : Kahn L‚ÇÅ ‚ÜíùíÑ Kahn I‚ÇÅ ‚ÜíùíÑ Kahn I‚ÇÇ ‚ÜíùíÑ Unit)
open ContinuousHom in
#check ŒªÀ°·µòÀ¢·µó ≥·µâ i‚ÇÅ i‚ÇÇ i‚ÇÉ => l‚ÇÅ l‚ÇÇ l‚ÇÉ => {foo}(l‚ÇÅ, i‚ÇÇ, i‚ÇÅ)

end Ast


instance : Add Env where
  add lhs rhs := ‚ü®Env.add.var lhs rhs, Env.add.type lhs rhs‚ü©

structure Node (I O: Env) where
  L : Env
  eqs : Str I ‚ÜíùíÑ Str L ‚ÜíùíÑ Str L
  out : Str I ‚ÜíùíÑ Str L ‚ÜíùíÑ Str O

noncomputable def Node.eval {I O: Env} (node: Node I O) : Str I ‚ÜíùíÑ Str O :=
  --Œª·∂ú i => {node.out}(i)({ContinuousHom.fix.comp node.eqs}(i))
  (ContinuousHom.Prod.curry.symm node.out).comp
    (ContinuousHom.Prod.prod
      ContinuousHom.id
      (ContinuousHom.fix.comp node.eqs)
    )

def Node.ensure {I O: Env} (node: Node I O)
  (P: Admissible (Str I)) (Q: Admissible (Str O)) : Prop :=
  ‚àÄ (i: Str I), i ‚àà P ‚Üí node.eval i ‚àà Q

@[refinment_type] def Node.induction {I O: Env} (node: Node I O)
  (P: Admissible (Str I)) (Q: Admissible (Str O)) (Inv: Admissible (Str node.L))
  (hyp: ‚àÄ (i: Str I) (l: Str node.L), i ‚àà P ‚Üí l ‚àà Inv ‚Üí node.eqs i l ‚àà Inv ‚àß node.out i l ‚àà Q)
  : node.ensure P Q := by
  intro i h‚ÇÅ
  have h‚ÇÉ : ContinuousHom.fix (node.eqs i) ‚àà Inv := by
    refinment_type
    intro l h‚ÇÇ
    apply (hyp _ _ h‚ÇÅ h‚ÇÇ).left
  apply (hyp _ _ h‚ÇÅ h‚ÇÉ).right


namespace Test

inductive I.var : Type where
| i

abbrev I.type : I.var ‚Üí Type
| .i => ‚Ñï

abbrev I : Env := ‚ü®I.var, I.type‚ü©

inductive O.var : Type where
| o

abbrev O.type : O.var ‚Üí Type
| .o => ‚Ñï

abbrev O : Env := ‚ü®O.var, O.type‚ü©

inductive L.var : Type where
| x | y | z

abbrev L.type : L.var ‚Üí Type
| .x => ‚Ñï
| .y => Bool
| .z => Bool

abbrev L : Env := ‚ü®L.var, L.type‚ü©

open Pi.OmegaCompletePartialOrder

#check ContinuousHom.Kahn.tup

abbrev ContinuousHom.Kahn.add {Œ±: Type u} [Add Œ±] : Kahn Œ± ‚ÜíùíÑ Kahn Œ± ‚ÜíùíÑ Kahn Œ± :=
  Œª·∂ú x y => {ContinuousHom.Kahn.map (Œª (x, y) => x+y)}(ContinuousHom.Kahn.tup(x, y))

def proj.i : Str I ‚ÜíùíÑ Kahn (I.type I.var.i) := proj .i

#check ContinuousHom.Kahn.fby

def Eqs : (l: L.var) ‚Üí Str I ‚ÜíùíÑ Str L ‚ÜíùíÑ Kahn (L.type l)
| .x => Œª·∂ú i l => ContinuousHom.Kahn.add(proj.i(i), {ContinuousHom.Kahn.fby (Kahn.const 0)}({proj L.var.x}(l)))
| .y => Œª·∂ú i l => {proj L.var.z}(l)
| .z => Œª·∂ú i l => {proj L.var.y}(l)

def Out : (v: O.var) ‚Üí Str I ‚ÜíùíÑ Str L ‚ÜíùíÑ Kahn (O.type v)
| .o => Œª·∂ú i l => {proj L.var.x}(l)


#check map
#check lift
#check proj

#check ContinuousHom.Prod.curry

def eqs : Str I ‚ÜíùíÑ Str L ‚ÜíùíÑ Str L :=
  ContinuousHom.Prod.curry (foreach (Œª v => ContinuousHom.Prod.curry.symm (Eqs v)))

@[simp] def eqs.apply (input: Str I) (loc: Str L) (l: L.var) : eqs input loc l = Eqs l input loc := rfl

def out : Str I ‚ÜíùíÑ Str L ‚ÜíùíÑ Str O :=
  ContinuousHom.Prod.curry (foreach (Œª v => ContinuousHom.Prod.curry.symm (Out v)))

@[simp] def out.apply (input: Str I) (loc: Str L) (v: O.var) : out input loc v = Out v input loc := rfl

@[simps! L eqs out]
def node : Node I O where
  L := L
  eqs := eqs
  out := out

noncomputable def node.spec.Input : (x: I.var) ‚Üí Admissible (Kahn (I.type x))
| .i => Square (Œª x => x > 0)

noncomputable def node.spec.Output : (x: O.var) ‚Üí Admissible (Kahn (O.type x))
| .o => Square (Œª x => x > 0)

noncomputable def node.spec.Local : (v: L.var) ‚Üí Admissible (Kahn (L.type v))
| .x => Square (Œª x => x > 0)
| .y => ‚ä§
| .z => ‚ä§


def node.proof : node.ensure (Admissible.foreach node.spec.Input) (Admissible.foreach node.spec.Output) := by
  apply Node.induction node _ _ (Admissible.foreach node.spec.Local)
  intro i l h‚ÇÅ h‚ÇÇ
  constructor
  ¬∑ refinment_type
    intro var
    cases var with
    | x =>
      simp [eqs.apply, Eqs]
      simp [proj.i]
      specialize h‚ÇÅ .i
      specialize h‚ÇÇ .x
      generalize i I.var.i = input at *
      generalize l L.var.x = loc at *
      cases input with
      | bot =>
        simp?
        refinment_type
      | cons x xs =>
        cases loc with
        | bot =>
          rw [Kahn.const.unfold]
          simp? [spec.Local]
          constructor
          ¬∑ simp only [spec.Input, Square.rewrite_cons] at h‚ÇÅ
            exact h‚ÇÅ.left
          ¬∑ refinment_type
        | cons y ys =>
          rw [Kahn.const.unfold]
          simp [spec.Local]
          sorry
    | y =>
      trivial
    | z =>
      trivial
  ¬∑ refinment_type
    intro var
    cases var with
    | o =>
      simp [Out]
      apply h‚ÇÇ

end Test

end Lustre
